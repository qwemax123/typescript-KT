//типы
type Currency = "rub"
type Money = { amount: number; currency: Currency }
type InvoiceStatus = "draft" | "issued" | "paid" | "void" // состояния счета


interface Billable {
    title: string
    total(): Money
}

abstract class InvoiceLine implements Billable {
    public readonly title: string

    protected constructor(title: string, protected readonly qty: number) {
        this.title = title
    }

    protected abstract unitPrice(): Money

    public total(): Money {
        const price = this.unitPrice()
        return { amount: price.amount * this.qty, currency: price.currency }
    }
}

class LaborLine extends InvoiceLine {
    constructor(title: string, qtyHours: number, private readonly rubPerHour: number) {
        super(title, qtyHours)
    }
    protected unitPrice(): Money {
        return { amount: this.rubPerHour, currency: "rub" }
    }
}

class Invoice {
    private status: InvoiceStatus = "draft"

    constructor(public readonly id: string, private readonly lines: Billable[]) { }

    public issue(): void {
        if (this.status !== "draft") throw new Error("can issae only from draft")
        this.status = "issued"
    }

    public markPaid(): void {
        if (this.status !== "issued") throw new Error("can pay only issued Invoice")
        this.status = "paid"
    }

    public getStatus(): InvoiceStatus {
        return this.status
    }

    public getLines(): readonly Billable[] {
        return this.lines
    }
}

class InvoiceCalculator {
    public sum(lines: readonly Billable[]): Money {
        return lines.reduce(
            (acc, line) => ({ amount: acc.amount + line.total().amount, currency: "rub" }),
            { amount: 0, currency: "rub" })
    }
}

type Paymentresult =
    | { ok: true; paidAt: string; method: string }
    | { ok: false; reason: "declined" | "network_error"; method: string };

interface PaymentMethod {
    methodName: string
    pay(invoice: Invoice, amount: Money): Paymentresult
}

class CashPayment implements PaymentMethod {
    public readonly methodName: "cash" = "cash";

    pay(invoice: Invoice, amount: Money): Paymentresult {
        if (invoice.getStatus() !== "issued") return { ok: false, reason: "declined", method: this.methodName }
        return { ok: true, paidAt: new Date().toISOString(), method: this.methodName }
    }
}

// 2 задание
class PartLine extends InvoiceLine {
    constructor(title: string, qty: number, private readonly rubPerHour: number, private readonly markup: number = 0.1) {
        super(title, qty)
    }
    protected unitPrice(): Money {
        return { amount: this.rubPerHour, currency: "rub" }
    }
    public total(): Money {
        const base = super.total()
        return { amount: base.amount * (1 + this.markup), currency: base.currency }
    }
}

function demo(): Invoice {
    const lines = [
        new LaborLine("диагностика", 2, 1500),
        new LaborLine("диагностика", 2, 1500),
        new LaborLine("диагностика", 2, 1500),
        new LaborLine("диагностика", 2, 1500),

        new PartLine("мотор", 1, 50000),
        new PartLine("мотор", 1, 50000),
        new PartLine("мотор", 1, 50000),
        new PartLine("мотор", 1, 50000),
    ]

    const invoice = new Invoice("INV-2026-0001", lines)

    // console.log(invoice)
    return invoice
}

async function demoSign(invoice: Invoice) {
    invoice.issue()
    const calculator = new InvoiceCalculator()
    const total:Money = calculator.sum(invoice.getLines())

    const payment = new CashPayment()
    const result = payment.pay(invoice, total)

    console.log(total)
    console.log(invoice)
    console.log(result)
}

const invoice = demo()
demoSign(invoice)
